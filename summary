
http://www.ardendertat.com/2012/01/09/programming-interview-questions/
https://leetcode.com/discuss/16669/c-solution-in-place-runtime-o-n-memory-o-1
' ' " " or " \t"??????
Reverse Words in a String
  /*Step 1: Trim whitespace from the beginning and end of the string.

Step 2: Clean up whitespace between words.

Step 3: Reverse each word in the sentence.

Step 4: Reverse the entire sentence.

The idea for both the whitespace cleanup code and the reverse code is two use two indices (or iterators or the like) to look for whitespace and non whitespace characters and handle the group of characters between them accordingly
*/
following use stringstream, but not O(1) space
void reverseWords(string &s) {
        stringstream is(s);
        is >> s;
        string temp;
        while(is >> temp){
            s = temp + " " + s;
        }
        if(s[0] == ' ') s="";
        
    }

Longest Substring Without Repeating Characters
int lengthOfLongestSubstring(string s) {
        unordered_map<char,int> mp;
        int start=0,maxLen=0;
        for(int i=0; i<s.size(); ++i){
            if(mp.count(s[i]) != 0){
                if(mp[s[i]] >= start){
                    maxLen = max(maxLen,i-start);
                    start = mp[s[i]]+1;
                }
            }
            mp[s[i]] = i;
        }
               
        
        return max(maxLen,(int)s.size()-start);
    }

Longest Palindromic Substring
string longestPalindrome(string s) {
       int len = s.size();
       //initialze array
       bool isPal[len][len]={false};
       int maxLen=1,start=0;
       for(int i=0; i<len; ++i){
           //need j<=i becasue the [i][i]
           for(int j=0; j<=i; ++j){
               //note, i-j<2!!!!!!!!
               if(s[i]==s[j] &&(i-j<2 || isPal[j+1][i-1])){
                   isPal[j][i] = true;
                   if(i-j+1>maxLen){
                       maxLen = i-j+1;
                       start=j;
                   }
               }
           }
        
       }
       return s.substr(start,maxLen);
    }


Letter Combinations of a Phone Number
https://leetcode.com/discuss/42518/iterative-c-solution-in-0ms
use swap becasue swap dows not use memcpy
This is iterative version
vector<string> letterCombinations(string digits) {
        const vector<string> converter = {"","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
        vector<string> result;
        if(digits.empty())
            return result;
        result.push_back("");
        for(auto d:digits){
            int n = result.size();
            int m = converter[d-'0'].size();
            const string& str = converter[d-'0'];
            if(str.empty())
                continue;
            vector<string> temp;
            
            for(int i=0; i<m; ++i){
                
                for(int j=0; j<n; ++j){
                    temp.push_back(result[j]+str[i]);
                }
            }
            result.swap(temp);
        }
        return result;
    }
    
this is back tracking version or dfs version
public:
    vector<string> letterCombinations(string digits) {
        const vector<string> converter = {"","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
        vector<string> result;
        if(digits.empty())
            return result;
        string path;
        backTrack(converter, digits, path, 0,result);
        return result;
    }
private:
    void backTrack(const vector<string> &c,const string &digits,string &p,int index,vector<string> &r){
        if(index == digits.size()){
            r.push_back(p);
            return;
        }
        for(int i=0; i<c[digits[index]-'0'].size(); ++i){
            p.push_back(c[digits[index]-'0'][i]);
            backTrack(c,digits,p,index+1,r);
            p.pop_back();
        }
            
    }
    
