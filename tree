1. Binary Tree Inorder Traversal
public:
    vector<int> inorderTraversal(TreeNode* root) {
        stack<struct TreeNode*> st;
        vector<int> result;
        struct TreeNode* cur = root;
        
        while(cur || !st.empty()){
           
           if(cur){
               
               st.push(cur);
               cur = cur->left;
               
           }else{
               cur = st.top();
               st.pop();
               result.push_back(cur->val);
               cur = cur->right;
           }
           
        }
        return result;
    }

2. Symmetric Tree
first, iterative version. use pair to store the left and right subnode
typedef pair<TreeNode*, TreeNode*> nodepair;
public:
    bool isSymmetric(TreeNode* root) {
        // Level-order BFS.
        queue<nodepair> q;
        if(root)
            q.push(make_pair(root->left,root->right));
        while(q.size()){
            nodepair p=q.front(); q.pop();
            if(p.first){
                if(!p.second)return false;
                if(p.first->val != p.second->val) return false;
                // the order of children pushed to q is the key to the solution.
                q.push(make_pair(p.first->left,p.second->right));
                q.push(make_pair(p.first->right,p.second->left));
            }
            else if(p.second) return false;
        }
        return true;
    }
    
    
recursive version   
public:
    bool isSymmetric(TreeNode* root) {
        if(root == NULL)
            return true;
        return (isSym(root->left,root->right));
    }
    private:
    bool isSym(TreeNode* node1, TreeNode* node2){
        if(node1 == NULL) return node2 == NULL;
        if(node2 == NULL) return false;
        if(node1->val != node2->val) return false;
        return isSym(node1->left, node2->right) && isSym(node1->right, node2->left);
    }
